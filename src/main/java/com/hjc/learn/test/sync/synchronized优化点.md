### synchronized优化点
* 锁粗化
  锁粗化就是将**「多个连续的加锁、解锁操作连接在一起」**，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。
* 锁消除
  Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，
  通过对运行上下文的扫描，经过逃逸分析（对象在函数中被使用，也可能被外部函数所引用，称为函数逃逸），
  去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的时间消耗。
* 锁升级
  Java1.5以后为了减少获取锁和释放锁带来的性能消耗，引入了偏向锁和轻量级锁，
  Synchronized的升级顺序是 「无锁-->偏向锁-->轻量级锁-->重量级锁，只会升级不会降级」
 
### 不同锁
* 偏向锁
  在大多数情况下，**锁总是由同一线程多次获得，不存在多线程竞争**，所以出现了偏向锁，
  其目标就是在只有一个线程执行同步代码块时，降低获取锁带来的消耗，提高性能
  （可以通过J V M参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态）
* 轻量级锁
  **轻量级锁考虑的是竞争锁对象的线程不多，持有锁时间也不长的场景。**
  因为阻塞线程需要CPU**从用户态转到内核态**，代价较大，
  如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失，所以干脆不阻塞这个线程，让它自旋一段时间等待锁释放。
  轻量级锁的获取主要有两种情况：
  ① 当关闭偏向锁功能时；
  ② 多个线程竞争偏向锁导致偏向锁升级为轻量级锁。 
* 重量级锁
  轻量级锁膨胀之后，就升级为重量级锁，重量级锁是依赖操作系统的MutexLock（互斥锁）来实现的，需要从用户态转到内核态，
  这个成本非常高，这就是为什么Java1.6之前Synchronized效率低的原因 